<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>G√©n√©rateur de Calculs Al√©atoires</title>
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            background-color: #ffffff;
            padding: 30px 40px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 700px;
            text-align: center;
        }
        h1 {
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .level-selector {
            margin-bottom: 20px;
            text-align: left;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        .level-selector label {
            margin-right: 15px;
            cursor: pointer;
            font-weight: 600;
        }
        #problem-display {
            font-size: 2.5em;
            margin: 40px 0;
            padding: 20px;
            background-color: #e9ecef;
            border-radius: 8px;
            min-height: 50px;
            border: 1px dashed #adb5bd;
        }
        #answer-display {
            margin-top: 20px;
            padding: 15px;
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            border-radius: 5px;
            text-align: left;
            display: none; /* Cach√© par d√©faut */
        }
        #answer-display strong {
            display: block;
            margin-bottom: 10px;
        }
        .controls button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        #generate-btn {
            background-color: #28a745;
            color: white;
        }
        #generate-btn:hover {
            background-color: #218838;
        }
        #solve-btn {
            background-color: #ffc107;
            color: #333;
        }
        #solve-btn:hover {
            background-color: #e0a800;
        }
        /* Style pour les √©tapes de solution pour un meilleur rendu */
        .solution-step {
            margin: 10px 0;
            line-height: 1.5;
        }
        .solution-step strong {
            display: inline-block;
            min-width: 150px; 
            color: #0056b3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¢ G√©n√©rateur de Calculs Al√©atoires</h1>
        
        <div class="level-selector">
            Niveau de difficult√© : 
            <label><input type="radio" name="level" value="1" checked> Niveau 1 (Base)</label>
            <label><input type="radio" name="level" value="2"> Niveau 2 (Complexe)</label>
            <label><input type="radio" name="level" value="3"> Niveau 3 (Super-Complexe)</label>
        </div>

        <p>Probl√®me √† r√©soudre :</p>
        <div id="problem-display">
            </div>

        <div class="controls">
            <button id="generate-btn">‚û°Ô∏è Nouveau Calcul</button>
            <button id="solve-btn">‚úîÔ∏è Afficher la Solution</button>
        </div>

        <div id="answer-display">
            <strong>Solution (avec √©tapes) :</strong>
            <div id="solution-steps"></div>
        </div>
    </div>

    <script>
        // Fonction utilitaire pour le Plus Grand Commun Diviseur (PGCD)
        function gcd(a, b) {
            return b ? gcd(b, a % b) : a;
        }
        
        // Fonction utilitaire pour le Plus Petit Commun Multiple (PPCM)
        function lcm(a, b) {
            if (a === 0 || b === 0) return 0;
            return Math.abs(a * b) / gcd(a, b);
        }

        // Fonction pour simplifier une fraction [num, den]
        function simplifyFraction(num, den) {
            if (den === 0) return [num, 0];
            if (num === 0) return [0, 1];
            
            const g = gcd(Math.abs(num), Math.abs(den));
            let newNum = num / g;
            let newDen = den / g;
            
            if (newDen < 0) {
                newNum = -newNum;
                newDen = -newDen;
            }
            return [newNum, newDen];
        }

        // Repr√©sente un nombre qui peut √™tre entier ou fractionnaire
        class NumberValue {
            constructor(numerator, denominator = 1) {
                [this.numerator, this.denominator] = simplifyFraction(numerator, denominator);
            }

            isNegative() {
                return this.numerator < 0;
            }

            isOne() {
                return this.numerator === 1 && this.denominator === 1;
            }

            isMinusOne() {
                return this.numerator === -1 && this.denominator === 1;
            }
            
            // Convertit en string LaTeX. Utilise \dfrac pour les fractions.
            toLatex(wrap = false) {
                let str;
                if (this.denominator === 1) {
                    str = `${this.numerator}`;
                } else if (this.denominator === 0) {
                    str = `\\text{ERREUR}`;
                } else {
                    // Utiliser \dfrac pour une meilleure lisibilit√©
                    str = `\\dfrac{${this.numerator}}{${this.denominator}}`;
                }

                // Ajoute des parenth√®ses si 'wrap' est vrai ET (le nombre est n√©gatif OU une fraction OU si c'est -1)
                if (wrap && (this.isNegative() || this.denominator !== 1 || this.isMinusOne())) {
                    return `\\left(${str}\\right)`; 
                }
                
                return str;
            }
            
            toValue() {
                return this.numerator / this.denominator;
            }
            
            add(other) {
                const num = this.numerator * other.denominator + other.numerator * this.denominator;
                const den = this.denominator * other.denominator;
                return new NumberValue(num, den);
            }

            subtract(other) {
                const num = this.numerator * other.denominator - other.numerator * this.denominator;
                const den = this.denominator * other.denominator;
                return new NumberValue(num, den);
            }
            
            multiply(other) {
                const num = this.numerator * other.numerator;
                const den = this.denominator * other.denominator;
                return new NumberValue(num, den);
            }

            // Division (multiplication par l'inverse)
            divide(other) {
                if (other.numerator === 0) {
                    return new NumberValue(0, 1);
                }
                const num = this.numerator * other.denominator;
                const den = this.denominator * other.numerator;
                return new NumberValue(num, den);
            }
            
            power(exp) {
                if (exp === 0) return new NumberValue(1, 1);
                if (exp < 0) {
                    const inv = new NumberValue(this.denominator, this.numerator);
                    return inv.power(-exp);
                }
                
                const num = Math.pow(this.numerator, exp);
                const den = Math.pow(this.denominator, exp);
                return new NumberValue(num, den);
            }
        }

        function generateRandomNumber() {
            const isFraction = Math.random() < 0.4;
            
            if (isFraction) {
                let num = Math.floor(Math.random() * 10) + 1; 
                let den = Math.floor(Math.random() * 9) + 2;
                
                if (num % den === 0) { num = Math.floor(Math.random() * 10) + 1; }
                if (Math.random() < 0.3) num = -num;
                
                return new NumberValue(num, den);
            } else {
                let num = Math.floor(Math.random() * 15) + 1;
                if (Math.random() < 0.1) num = 1; 
                else if (Math.random() < 0.1) num = -1;
                else if (Math.random() < 0.3) num = -num;
                
                return new NumberValue(num, 1);
            }
        }

        /**
         * G√©n√®re les √©tapes de l'addition ou soustraction de fractions avec le d√©nominateur commun en couleur.
         */
        function generateAdditionSteps(B, C, operator, finalResult) {
            let steps = [];

            if (B.denominator !== 1 || C.denominator !== 1) {
                const denB = B.denominator;
                const denC = C.denominator;
                const commonDen = lcm(denB, denC);

                const B_factor = commonDen / denB;
                const C_factor = commonDen / denC;

                const numB_new = B.numerator * B_factor;
                const numC_new = C.numerator * C_factor;
                
                // √âtape 1: Mise au m√™me d√©nominateur (avec facteurs de couleur bleue)
                const B_display = B_factor === 1 ? B.toLatex(false) : `\\dfrac{${B.numerator} \\times \\color{blue}{${B_factor}}}{${B.denominator} \\times \\color{blue}{${B_factor}}}`;
                
                let C_content = `\\dfrac{${C.numerator} \\times \\color{blue}{${C_factor}}}{${C.denominator} \\times \\color{blue}{${C_factor}}}`;
                const C_display = (C_factor === 1 && !C.isNegative() && C.denominator === 1) ? C.toLatex(true) : `\\left( ${C_content} \\right)`;
                
                steps.push(`Mise au m√™me d√©nominateur: ${B_display} ${operator} ${C_display}`);
                
                // √âtape 2: Calcul sur les num√©rateurs (Gestion des double-signes)
                
                let numerator_calc;
                if (operator === '-' && numC_new < 0) {
                    numerator_calc = `${numB_new} + ${Math.abs(numC_new)}`;
                } else if (operator === '+' && numC_new < 0) {
                    numerator_calc = `${numB_new} - ${Math.abs(numC_new)}`;
                } else {
                    numerator_calc = `${numB_new} ${operator} ${numC_new}`;
                }
                
                const resultStepLatex = `\\dfrac{${numerator_calc}}{\\color{red}{${commonDen}}} = ${finalResult.toLatex()}`;
                steps.push(`Calcul sur fractions: ${resultStepLatex}`);
                
            } else {
                // Si entiers
                steps.push(`Addition/Soustraction: ${B.toLatex()} ${operator} ${C.toLatex(true)} = ${finalResult.toLatex()}`);
            }

            return steps;
        }
        
        /**
         * Applique al√©atoirement une puissance (2 ou 3) √† un terme.
         */
        function applyRandomPower(term) {
            if (Math.random() < 0.3) {
                const exp = Math.floor(Math.random() * 2) + 2; 
                const result = term.power(exp);
                const termLatex = term.toLatex(true);
                const stepLatex = `${termLatex}^{${exp}} = ${result.toLatex()}`;
                return { value: result, latex: `${termLatex}^{${exp}}`, steps: [`Puissance: ${stepLatex}`] };
            }
            return { value: term, latex: term.toLatex(false), steps: [] }; 
        }

        /**
         * G√©n√®re une expression complexe entre parenth√®ses, de la forme (A [op] B)^n.
         * La division est toujours repr√©sent√©e par une fraction dans le LaTeX final.
         */
        function generateInnerExpression() {
            let steps = [];

            let A_term = applyRandomPower(generateRandomNumber());
            let B_term = applyRandomPower(generateRandomNumber());

            steps.push(...A_term.steps);
            steps.push(...B_term.steps);

            let A = A_term.value;
            let B = B_term.value;
            let A_latex = A_term.latex;
            let B_latex = B_term.latex;

            const operations = ['+', '-', 'mult', 'div'];
            const op_type = operations[Math.floor(Math.random() * operations.length)];
            const op_symbol = op_type === 'mult' ? '\\times' : op_type === 'div' ? '\\div' : op_type;

            let result;
            let innerLatex;

            switch (op_type) {
                case '+':
                case '-':
                    result = (op_type === '+') ? A.add(B) : A.subtract(B);
                    steps.push(...generateAdditionSteps(A, B, op_type, result));
                    innerLatex = `${A_latex} ${op_type} ${B_latex}`;
                    break;
                case 'mult':
                    result = A.multiply(B);
                    if (!A.isOne() || !B.isOne()) {
                        if (A.isMinusOne() || B.isMinusOne()) {
                            let otherTerm = A.isMinusOne() ? B : A;
                            steps.push(`Multiplication (Changement de signe): - ${otherTerm.toLatex(true)} = ${result.toLatex()}`);
                        } else if (!A.isOne() && !B.isOne()) {
                            steps.push(`Multiplication: ${A.toLatex(true)} \\times ${B.toLatex(true)} = ${result.toLatex()}`);
                        }
                    }
                    innerLatex = `${A_latex} \\times ${B_latex}`;
                    break;
                case 'div':
                    if (B.numerator === 0) { B = new NumberValue(Math.floor(Math.random() * 5) + 1); }
                    result = A.divide(B);
                    
                    let mainStepLatex = `Division (Fraction): \\dfrac{${A.toLatex(false)}}{${B.toLatex(false)}} = ${result.toLatex()}`; 
                    steps.push(mainStepLatex);
                    
                    innerLatex = `\\dfrac{${A_latex}}{${B_latex}}`; 
                    break;
            }

            // Application de la puissance sur le r√©sultat de la parenth√®se
            let finalResult = result;
            let finalLatex;

            if (Math.random() < 0.15) {
                const exp = Math.floor(Math.random() * 2) + 2;
                finalResult = result.power(exp);
                const stepLatex = `\\left(${result.toLatex(false)}\\right)^{${exp}} = ${finalResult.toLatex()}`;
                steps.push(`Puissance (parenth√®se): ${stepLatex}`);
                
                finalLatex = `\\left( ${innerLatex} \\right)^{${exp}}`;
            } else {
                 if (op_type === 'div') {
                    finalLatex = innerLatex;
                 } else {
                    finalLatex = `\\left( ${innerLatex} \\right)`; 
                 }
            }

            return { result: finalResult, latex: finalLatex, steps: steps, op_type: op_type };
        }


        // --- NIVEAU 1 : A * B^n +/- C ---
        function generateSimpleProblem() {
            let steps = [];

            const A = generateRandomNumber();
            let B_term;
            let resultBeforeAddition;
            let problemLatexBeforeC = A.toLatex();
            
            const usePower = Math.random() < 0.5;
            let exponent = 0;

            if (usePower) {
                const B = generateRandomNumber();
                exponent = Math.floor(Math.random() * 2) + 2;
                
                const bLatexWrapped = B.toLatex(true); 
                problemLatexBeforeC = `${A.toLatex()} \\times ${bLatexWrapped}^{${exponent}}`;
                
                const B_power = B.power(exponent);
                steps.push(`Puissance: ${B.toLatex(true)} ^{${exponent}} = ${B_power.toLatex()}`);
                
                resultBeforeAddition = A.multiply(B_power);
                B_term = resultBeforeAddition;

                if (!A.isOne() || !B_power.isOne()) {
                    if (A.isMinusOne() || B_power.isMinusOne()) {
                        let otherTerm = A.isMinusOne() ? B_power : A;
                        steps.push(`Changement de signe (Multiplication par -1): - ${otherTerm.toLatex()} = ${resultBeforeAddition.toLatex()}`);
                    } else if (!A.isOne() && !B_power.isOne()) {
                        steps.push(`Multiplication: ${A.toLatex()} \\times ${B_power.toLatex(true)} = ${resultBeforeAddition.toLatex()}`);
                    }
                }
                
            } else {
                const B = generateRandomNumber();
                
                resultBeforeAddition = A.multiply(B);
                B_term = resultBeforeAddition;
                
                if (!A.isOne() || !B.isOne()) {
                    if (A.isMinusOne() || B.isMinusOne()) {
                        let otherTerm = A.isMinusOne() ? B : A;
                        problemLatexBeforeC = `${A.toLatex()} \\times ${B.toLatex(true)}`;
                        steps.push(`Changement de signe (Multiplication par -1): - ${otherTerm.toLatex()} = ${resultBeforeAddition.toLatex()}`);
                    } else if (!A.isOne() && !B.isOne()) {
                        problemLatexBeforeC = `${A.toLatex()} \\times ${B.toLatex(true)}`;
                        steps.push(`Multiplication: ${A.toLatex()} \\times ${B.toLatex(true)} = ${resultBeforeAddition.toLatex()}`);
                    }
                } else {
                    problemLatexBeforeC = B.toLatex();
                }
            }
            
            const C = generateRandomNumber();
            const operator = Math.random() < 0.5 ? "+" : "-";
            
            const latex = `${problemLatexBeforeC} ${operator} ${C.toLatex(true)}`;
            
            const finalResult = (operator === '+') ? B_term.add(C) : B_term.subtract(C);
            steps.push(...generateAdditionSteps(B_term, C, operator, finalResult));

            return { latex, steps, result: finalResult.toLatex() };
        }

        // --- NIVEAU 2 : (A/B +/- C) * D^n  OU  (A +/- B/C) * D^n ---
        function generateComplexProblem() {
            let steps = [];

            const N1 = generateRandomNumber();
            const N2 = generateRandomNumber();
            const N3 = generateRandomNumber();
            let D = generateRandomNumber(); 
            
            // Choisir si la division est le premier terme ou le deuxi√®me
            const division_first = Math.random() < 0.5;
            
            let term1;
            let term2;

            // 1. Calcul de la division (qui est le terme complexe interne)
            if (division_first) { // (N1/N2 +/- N3) * D^n
                term1 = N1.divide(N2);
                term2 = N3;
                steps.push(`Division interne (Terme 1): \\dfrac{${N1.toLatex(false)}}{${N2.toLatex(false)}} = ${term1.toLatex()}`);
            } else { // (N1 +/- N2/N3) * D^n
                term1 = N1;
                term2 = N2.divide(N3);
                steps.push(`Division interne (Terme 2): \\dfrac{${N2.toLatex(false)}}{${N3.toLatex(false)}} = ${term2.toLatex()}`);
            }
            
            // 2. Addition/Soustraction (Op√©ration prioritaire entre parenth√®ses)
            const operator = Math.random() < 0.5 ? "+" : "-";
            const innerCalculation = (operator === '+') ? term1.add(term2) : term1.subtract(term2);
            
            steps.push(`R√©solution de la parenth√®se: ${term1.toLatex(false)} ${operator} ${term2.toLatex(true)}`);
            steps.push(...generateAdditionSteps(term1, term2, operator, innerCalculation));

            // Construction LaTeX interne
            const innerExpressionLatex = `\\left(${division_first ? term1.toLatex(false) : term1.toLatex(false)} ${operator} ${division_first ? N3.toLatex(true) : term2.toLatex(true)}\\right)`;


            // 3. Multiplication/Puissance avec D
            const usePower = Math.random() < 0.6;
            let finalResult;
            let D_term_latex = "";
            let D_factor; 
            
            if (usePower) {
                const exponent = Math.floor(Math.random() * 2) + 2;
                
                const D_power = D.power(exponent);
                steps.push(`Puissance: ${D.toLatex(true)} ^{${exponent}} = ${D_power.toLatex()}`);

                D_factor = D_power;
                D_term_latex = `${D.toLatex(true)}^{${exponent}}`;

            } else {
                D_factor = D;
                D_term_latex = D.toLatex(true);
            }
            
            // Calcul final (Multiplication)
            finalResult = innerCalculation.multiply(D_factor);
                
            // Documentation de l'√©tape de multiplication finale
            if (!D_factor.isOne() || !innerCalculation.isOne()) {
                if (D_factor.isMinusOne() || innerCalculation.isMinusOne()) {
                    let otherTerm = innerCalculation.isMinusOne() ? D_factor : innerCalculation;
                    steps.push(`Multiplication Finale (Changement de signe): - ${otherTerm.toLatex(true)} = ${finalResult.toLatex()}`);
                } else if (!D_factor.isOne() && !innerCalculation.isOne()) {
                    steps.push(`Multiplication Finale: ${innerCalculation.toLatex(true)} \\times ${D_factor.toLatex(true)} = ${finalResult.toLatex()}`);
                }
            }
            
            let latex = `${innerExpressionLatex} \\times ${D_term_latex}`;
            
            if (D_factor.isOne()) {
                latex = innerExpressionLatex;
            }

            return { latex, steps, result: finalResult.toLatex() };
        }

        // --- NIVEAU 3 : (Op√©ration Al√©atoire avec Puissance) [Op] (Op√©ration Al√©atoire avec Puissance) ---
        function generateSuperComplexProblem() {
            
            const P1 = generateInnerExpression();
            const P2 = generateInnerExpression();

            const P1_result = P1.result;
            const P2_result = P2.result;

            let steps = P1.steps.map(s => `Parenth√®se 1: ${s}`);
            steps.push(...P2.steps.map(s => `Parenth√®se 2: ${s}`));

            const outer_operations = ['+', '-', 'mult', 'div'];
            const outer_op_type = outer_operations[Math.floor(Math.random() * outer_operations.length)];
            const outer_op_symbol = outer_op_type === 'mult' ? '\\times' : outer_op_type === 'div' ? '' : outer_op_type;

            let finalResult;
            let latex;

            switch (outer_op_type) {
                case '+':
                case '-':
                    const op = outer_op_type;
                    finalResult = (op === '+') ? P1_result.add(P2_result) : P1_result.subtract(P2_result);
                    steps.push(...generateAdditionSteps(P1_result, P2_result, op, finalResult).map(s => `Op√©ration Finale (${op}): ${s}`));
                    latex = `${P1.latex} ${outer_op_symbol} ${P2.latex}`;
                    break;
                case 'mult':
                    finalResult = P1_result.multiply(P2_result);
                    
                    if (!P1_result.isOne() || !P2_result.isOne()) {
                        let finalStepLatex = `Multiplication: ${P1_result.toLatex(true)} \\times ${P2_result.toLatex(true)} = ${finalResult.toLatex()}`;
                        steps.push(`Op√©ration Finale: ${finalStepLatex}`);
                    }
                    latex = `${P1.latex} ${outer_op_symbol} ${P2.latex}`;
                    break;
                case 'div':
                    if (P2_result.numerator === 0) {
                        finalResult = new NumberValue(0, 1);
                    } else {
                        finalResult = P1_result.divide(P2_result);
                    }
                    
                    let finalStepLatex = `\\dfrac{${P1_result.toLatex(false)}}{${P2_result.toLatex(false)}} = ${finalResult.toLatex()}`; 
                    steps.push(`Op√©ration Finale (Fraction): ${finalStepLatex}`);

                    // Construction LaTeX finale (en grande fraction)
                    latex = `\\dfrac{${P1.latex}}{${P2.latex}}`;
                    break;
            }
            
            return { latex, steps, result: finalResult.toLatex() };
        }


        // --- FONCTION PRINCIPALE D'AFFICHAGE ---
        function updateDisplay() {
            const level = document.querySelector('input[name="level"]:checked').value;
            let problemData;

            if (level === '1') {
                problemData = generateSimpleProblem();
            } else if (level === '2') {
                problemData = generateComplexProblem();
            } else { // level === '3'
                problemData = generateSuperComplexProblem();
            }

            const { latex, steps, result } = problemData;
            
            const problemDisplay = document.getElementById('problem-display');
            problemDisplay.innerHTML = `$$${latex}$$`;
            
            
            const answerContainer = document.getElementById('answer-display');
            let oldSolutionDiv = document.getElementById('solution-steps');
            
            // 1. Supprimer et recr√©er l'√©l√©ment de solution pour un rendu propre
            if (oldSolutionDiv) {
                if (window.MathJax && window.MathJax.typesetClear) {
                    MathJax.typesetClear([oldSolutionDiv]);
                }
                oldSolutionDiv.remove();
            }

            let newSolutionDiv = document.createElement('div');
            newSolutionDiv.id = 'solution-steps';
            newSolutionDiv.style.textAlign = 'left';
            
            // 2. Pr√©parer le contenu HTML/LaTeX avec une structure par √©tape (structure robuste)
            let solutionHtml = '';

            steps.forEach(step => {
                const parts = step.split(': ');
                const textPart = parts[0];
                const latexPart = parts.slice(1).join(': '); 

                solutionHtml += `<div class="solution-step">`;
                solutionHtml += `&triangleright; <strong>${textPart.trim()}</strong>: `;
                // Mode math√©matique en ligne \( ... \) pour le LaTeX
                solutionHtml += `\\(${latexPart}\\)`; 
                solutionHtml += `</div>`;
            });

            // Ajout du r√©sultat final
            solutionHtml += `<div class="solution-step">`;
            solutionHtml += `&triangleright; <strong>R√©sultat Final</strong>: `;
            solutionHtml += `\\(${result}\\)`; 
            solutionHtml += `</div>`;

            newSolutionDiv.innerHTML = solutionHtml;
            answerContainer.appendChild(newSolutionDiv);
            
            // 3. Forcer le rendu MathJax sur les deux √©l√©ments (Probl√®me et Solution)
            if (window.MathJax) {
                MathJax.typesetPromise([problemDisplay, newSolutionDiv]).then(() => {
                    answerContainer.style.display = 'none';
                });
            } else {
                answerContainer.style.display = 'none';
            }
        }

        // --- INITIALISATION ET √âV√âNEMENTS ---

        document.getElementById('generate-btn').addEventListener('click', updateDisplay);

        // D√©clencher un nouveau calcul si le niveau change
        document.querySelectorAll('input[name="level"]').forEach(radio => {
            radio.addEventListener('change', updateDisplay);
        });

        document.getElementById('solve-btn').addEventListener('click', function() {
            const answerDisplay = document.getElementById('answer-display');
            answerDisplay.style.display = (answerDisplay.style.display === 'none' || answerDisplay.style.display === '') ? 'block' : 'none';
        });

        // Initialisation: S'assurer que MathJax est pr√™t.
        window.onload = function() {
            if (window.MathJax) {
                window.MathJax.startup.promise.then(updateDisplay);
            } else {
                updateDisplay();
            }
        };
    </script>
</body>
</html>